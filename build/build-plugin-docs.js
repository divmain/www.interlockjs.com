const fetch = require("node-fetch");
const pug = require("pug");


const PLUGINS_DATA = "https://api.github.com/repos/interlockjs/plugins/contents/packages";


const pluginReadmeUrl = plugin => 
  `https://raw.githubusercontent.com/interlockjs/plugins/master/packages/${plugin}/README.md`;


const indent = (text, _indent) => text
  .split("\n")
  .map(line => _indent + line)
  .join("\n");


const formatMarkdown = markdown => {
  const [ header, ...rest ] = markdown.split("\n");
  const content = rest.join("\n");
  const title = header.split(" ").splice(1).join(" ");

  const sections = content ?
    content
      .split("\n## ")
      .map(str => `## ${str}`)
      .slice(1) :
    [];

  return { title, sections };
};

const sectionSplitter = `
  section.glass
`;

const getSectionId = section => {
  const match = section.match(/^## +([^\n]+)/);
  if (!match) { return "unknown"; }
  return match[1]
    .toLowerCase()
    .replace(/ +/, "-");
};

const renderSection = (section, sectionTitle) => `
  section#${getSectionId(section)}
    .content
      :markdown-it
${indent(section, "        ")}
`;

const getJadeTemplate = (sections, title, url) => `
extends ../../_layout.jade

block content

  section.glass.heading
    h1 ${title}
    .repo-links
      a(class="repo-link" href="${url}") repo

${sections.map(renderSection).join(sectionSplitter)}
`;


const getAutogenModuleSeeds = opts => {
  return fetch(PLUGINS_DATA)
    .then(res => res.json())
    .then(pluginsMetadata => Promise.all(pluginsMetadata.map(pluginMetadata => {
      const { name, html_url: url } = pluginMetadata;
      return fetch(pluginReadmeUrl(name))
        .then(res => res.text())
        .then(markdown => ({ name, markdown, url }))
    })))
    .then(pluginsContent => {
      const pluginEntries = pluginsContent.map(pluginContent => {
        const { name, markdown, url } = pluginContent;
        const { title, sections } = formatMarkdown(markdown);

        return {
          path: `${opts.srcRoot}/docs/plugins/${name}.jade`,
          ns: opts.ns,
          nsPath: `docs/plugins/${name}.jade`,
          nsRoot: opts.srcRoot,
          uri: `${opts.ns}:docs/plugins/${name}.jade`,
          __plugin_autogen__: true,
          rawSource: getJadeTemplate(sections, title, url)
        }
      });

      return pluginEntries.reduce((memo, entry) => {
        memo[entry.nsPath] = entry;
        return memo;
      }, {});
    })

};

module.exports = (opts = {}) => {
  const dest = opts.dest || "/docs/plugins";

  return (override, transform) => {
    transform("getModuleSeeds", function (moduleSeedsByRelPath) {
      return getAutogenModuleSeeds(this.opts)
        .then(autogenModuleSeeds =>
          Object.assign({}, moduleSeedsByRelPath, autogenModuleSeeds)
        );
    });

    override("readSource", module => {
      // If the module is autogenerated, it will already have a `rawSource`
      // property attached.
      return module.__plugin_autogen__ ? module : override.CONTINUE;
    });

    transform("getBundleSeeds", function (bundleSeeds, [, modulesByAbsPath]) {
      const autogenBundlesP = Object.keys(modulesByAbsPath)
        .map(absPath => modulesByAbsPath[absPath])
        .filter(module => module.__plugin_autogen__)
        .map(module => this.initBundle({
          module,
          moduleHashes: [],
          dest: module.nsPath.replace(/\.jade$/, ".html"),
          type: module.type
        }));

      return Promise.all(autogenBundlesP)
        .then(autogenBundles => bundleSeeds.concat(autogenBundles));
    });
  };
};
