header.landing
  .logo-wrapper
    include _assets/interlock-logo.svg

  .landing-header
    h1 Interlock.js
    p.subtitle Unify your build.
    a.cta Get Started
    a.cta(href="//github.com/interlockjs/interlock") Open on GitHub


section
  .content
    h2 A build tool for universal javascript and beyond.

    .bullet-points
      .bullet-point
        .illustration
          include _assets/first-class.svg
        span First-class support for CSS and HTML.
        span lorem ipsum
      .bullet-point
        .illustration
        span Universal
          include _assets/universal.svg
        span Clean Node.js builds, feature parity with browser builds.
      .bullet-point
        .illustration
          include _assets/future-readiness.svg
        span Future ready
        span Rich support for HTTP/2, lorem ipsum
      .bullet-point
        .illustration
          include _assets/extensibility.svg
        span Powerful extensibility
        span A simple and straightforward plugin system.


section.friendly
  .content
    :markdown
      ## Friendly

      As a design principle, Interlock fully embraces the [Zen of Python](https://www.python.org/doc/humor/#the-zen-of-python), both for its internal implementation and for all developer-facing tools and interfaces.

      With a small investment, we hope that 

section.extensible
  .content
    :markdown
      ## Extensible

      The core of Interlock is very small - most features that Interlock is provided through the suite of official plugins.  All compilation steps are fully documented with an exploratory interface, an

      As a point of clarification, Interlock makes no distinction between "loaders" and "plugins"; ultimately, both effect the output of the build.  And with other tools, the line has often become rather blurry, in practice.

      a.cta Developer documentation
      a.cta Example plugins

section.getting-started
  .content
    :markdown
      ## Getting Started

      getting started, bacon ipsum, etc etc etc

      **Interlock is a bundler and build pipeline for the modern web.**

      - modularity
      - comprehensibility
      - extensibility
      - support for HTTP/2 server push
      - tree shaking
      - CSS as a first-class citizen (no more extract-text-plugin)
      - powerful dev server
      - CDN that is wired up to NPM (and cached)
      - flexible bundling - use the bundling scheme that works best for you. by default uses similar bundling scheme as [StealJS](http://stealjs.com/docs/index.html)

      It provides first-class support for ECMAScript via Babel and CSS via PostCSS.  Its module system promotes modularity at any level of granularity, without sacrificing performance, accommodating teams of two or teams of two hundred.

      It aims to be comprehensible and extensible through plugins.


section.why-interlock
  .content
    :markdown
      ## Why Interlock?


section.migration-path
  .content
    :markdown
      ## Strong migration path

      Do you use RequireJS? [Utilize the Interlock-RequireJS interop layer to integrate an Interlock build iteratively.](#)
      Do you use Webpack? [Keep using the same Webpack loaders with our loader compatibility layer.](#)
      Do you use Browserify? [We provide a compatibility layer for Browserify transforms, too!](#)


section.module-system
  aside
    img(src="/images/module-system.svg")
  .content
    :markdown
      ## Powerful module system
      //- Scalable

      Interlock features a powerful module system, inspired by Git's object database.  Each source module is assigned a canonical ID, generated as a hash of the module's content and certain meta-data, including the IDs of all its dependencies.  At run-time these modules can be referenced without concern for collisions between project versions.

      In practice, the module system obviates entire categories of problems related to caching and **sharing code across teams and builds**.  It allows the developer to select the appropriate level of granularity at which components and projects are built and deployed.

      And it does this without sacrificing performance or development ergonomics, whether you're a team of two or a team of two hundred.


section.extensibility
  .content
    :markdown
      ## Extensible

      Interlock makes ease-of-extensibility a top priority.  Every step of the build process can be extended or overridden, extension points are consistent, and documentation for those extension points is guaranteed to be up-to-date by Interlock's CI.

      With Interlock, there is no divide between plugins and loaders.  Only plugins are needed, and can be used to transform or override the output of any step of the build process.  Everything is asynchronous, so you can read from the file-system or query some remote service if you need to.

      Interlock uses AST as the intermediate representation of your JavaScript code, leading to excellent compatibility with tools like ESLint and Babel.  In fact, Interlock is built on top of Babel, and has support baked right in.

      Interlock is extensible in a number of other ways - through alternate build pipelines for non-JavaScript like CSS, or through the run-time module-loading behavior.

      Continue learning with our [interactive documentation](/docs/extensibility).

  //- show example JSON plugin
  

section.quality
  .content
    :markdown
      ## High code quality

      test coverage
      modern ES6 code
      prefer functional, except where impractical

